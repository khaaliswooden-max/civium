// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/**
 * @title ComplianceVerifier
 * @notice On-chain verification of ZK-SNARK compliance proofs
 * @dev Uses Groth16 proofs over BN254 curve
 * 
 * This contract verifies zero-knowledge proofs that demonstrate:
 * - An entity's compliance score meets or exceeds a threshold
 * - The actual score remains private
 * - The proof is bound to a specific entity via hash
 * 
 * @author Civium Compliance Engine
 * @custom:security-contact security@civium.io
 */
contract ComplianceVerifier {
    // =========================================================================
    // Errors
    // =========================================================================
    
    error InvalidProof();
    error ProofAlreadyUsed();
    error InvalidThreshold();
    error InvalidPairingInput();
    error VerificationFailed();
    
    // =========================================================================
    // Events
    // =========================================================================
    
    /**
     * @notice Emitted when a compliance proof is verified
     * @param entityHash Hash of the entity identifier
     * @param threshold The minimum score threshold proven
     * @param commitment The score commitment (can be used for future proofs)
     * @param timestamp Block timestamp of verification
     */
    event ComplianceVerified(
        uint256 indexed entityHash,
        uint256 threshold,
        uint256 commitment,
        uint256 timestamp
    );
    
    /**
     * @notice Emitted when a range proof is verified
     */
    event RangeVerified(
        uint256 indexed entityHash,
        uint256 minScore,
        uint256 maxScore,
        uint256 commitment,
        uint256 timestamp
    );
    
    /**
     * @notice Emitted when a tier membership proof is verified
     */
    event TierVerified(
        uint256 indexed entityHash,
        uint8 tier,
        uint256 commitment,
        uint256 timestamp
    );
    
    // =========================================================================
    // State
    // =========================================================================
    
    /// @notice Mapping of proof hashes to prevent replay attacks
    mapping(bytes32 => bool) public usedProofs;
    
    /// @notice Mapping of entity hash to latest verified commitment
    mapping(uint256 => uint256) public latestCommitments;
    
    /// @notice Mapping of entity hash to last verification timestamp
    mapping(uint256 => uint256) public lastVerificationTime;
    
    // =========================================================================
    // Verification Key (set during deployment or via trusted setup)
    // These values are generated by snarkjs during trusted setup
    // =========================================================================
    
    // BN254 curve order
    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;
    
    // Verification key elements
    uint256 constant ALPHA_X = 0;
    uint256 constant ALPHA_Y = 0;
    uint256 constant BETA_X1 = 0;
    uint256 constant BETA_X2 = 0;
    uint256 constant BETA_Y1 = 0;
    uint256 constant BETA_Y2 = 0;
    uint256 constant GAMMA_X1 = 0;
    uint256 constant GAMMA_X2 = 0;
    uint256 constant GAMMA_Y1 = 0;
    uint256 constant GAMMA_Y2 = 0;
    uint256 constant DELTA_X1 = 0;
    uint256 constant DELTA_X2 = 0;
    uint256 constant DELTA_Y1 = 0;
    uint256 constant DELTA_Y2 = 0;
    
    // IC (input commitment) points - will be populated by setup
    // IC[0] is for constant 1
    // IC[1] is for public input: threshold
    // IC[2] is for public input: entityHash
    // IC[3] is for public output: scoreCommitment
    
    // =========================================================================
    // Structs
    // =========================================================================
    
    struct Proof {
        uint256[2] a;      // G1 point
        uint256[2][2] b;   // G2 point
        uint256[2] c;      // G1 point
    }
    
    struct VerifyingKey {
        uint256[2] alpha;
        uint256[2][2] beta;
        uint256[2][2] gamma;
        uint256[2][2] delta;
        uint256[2][] ic;
    }
    
    // =========================================================================
    // Public Functions
    // =========================================================================
    
    /**
     * @notice Verify a compliance threshold proof
     * @param _proof The Groth16 proof (a, b, c points)
     * @param _threshold The minimum score threshold being proven (public input)
     * @param _entityHash Hash of entity identifier (public input)
     * @return commitment The score commitment (public output)
     * 
     * @dev The proof demonstrates that the prover knows a score >= threshold
     *      without revealing the actual score.
     */
    function verifyThreshold(
        uint256[8] calldata _proof,
        uint256 _threshold,
        uint256 _entityHash
    ) external returns (uint256 commitment) {
        // Validate threshold is in valid range (0-10000)
        if (_threshold > 10000) revert InvalidThreshold();
        
        // Construct proof struct
        Proof memory proof = Proof({
            a: [_proof[0], _proof[1]],
            b: [[_proof[2], _proof[3]], [_proof[4], _proof[5]]],
            c: [_proof[6], _proof[7]]
        });
        
        // Public inputs: [threshold, entityHash]
        uint256[] memory pubInputs = new uint256[](2);
        pubInputs[0] = _threshold;
        pubInputs[1] = _entityHash;
        
        // Verify the proof
        (bool success, uint256 scoreCommitment) = _verifyProof(proof, pubInputs);
        
        if (!success) revert VerificationFailed();
        
        // Prevent replay attacks
        bytes32 proofHash = keccak256(abi.encode(_proof, _threshold, _entityHash));
        if (usedProofs[proofHash]) revert ProofAlreadyUsed();
        usedProofs[proofHash] = true;
        
        // Update state
        latestCommitments[_entityHash] = scoreCommitment;
        lastVerificationTime[_entityHash] = block.timestamp;
        
        emit ComplianceVerified(_entityHash, _threshold, scoreCommitment, block.timestamp);
        
        return scoreCommitment;
    }
    
    /**
     * @notice Verify a range proof
     * @param _proof The Groth16 proof
     * @param _minScore Minimum score of range (public)
     * @param _maxScore Maximum score of range (public)
     * @param _entityHash Hash of entity identifier (public)
     * @return commitment The score commitment
     */
    function verifyRange(
        uint256[8] calldata _proof,
        uint256 _minScore,
        uint256 _maxScore,
        uint256 _entityHash
    ) external returns (uint256 commitment) {
        if (_minScore > _maxScore || _maxScore > 10000) revert InvalidThreshold();
        
        Proof memory proof = Proof({
            a: [_proof[0], _proof[1]],
            b: [[_proof[2], _proof[3]], [_proof[4], _proof[5]]],
            c: [_proof[6], _proof[7]]
        });
        
        uint256[] memory pubInputs = new uint256[](3);
        pubInputs[0] = _minScore;
        pubInputs[1] = _maxScore;
        pubInputs[2] = _entityHash;
        
        (bool success, uint256 scoreCommitment) = _verifyProof(proof, pubInputs);
        if (!success) revert VerificationFailed();
        
        bytes32 proofHash = keccak256(abi.encode(_proof, _minScore, _maxScore, _entityHash));
        if (usedProofs[proofHash]) revert ProofAlreadyUsed();
        usedProofs[proofHash] = true;
        
        latestCommitments[_entityHash] = scoreCommitment;
        lastVerificationTime[_entityHash] = block.timestamp;
        
        emit RangeVerified(_entityHash, _minScore, _maxScore, scoreCommitment, block.timestamp);
        
        return scoreCommitment;
    }
    
    /**
     * @notice Verify a tier membership proof
     * @param _proof The Groth16 proof
     * @param _tier Target tier (1-5)
     * @param _entityHash Hash of entity identifier
     * @return commitment The score commitment
     */
    function verifyTier(
        uint256[8] calldata _proof,
        uint8 _tier,
        uint256 _entityHash
    ) external returns (uint256 commitment) {
        if (_tier < 1 || _tier > 5) revert InvalidThreshold();
        
        Proof memory proof = Proof({
            a: [_proof[0], _proof[1]],
            b: [[_proof[2], _proof[3]], [_proof[4], _proof[5]]],
            c: [_proof[6], _proof[7]]
        });
        
        uint256[] memory pubInputs = new uint256[](2);
        pubInputs[0] = uint256(_tier);
        pubInputs[1] = _entityHash;
        
        (bool success, uint256 scoreCommitment) = _verifyProof(proof, pubInputs);
        if (!success) revert VerificationFailed();
        
        bytes32 proofHash = keccak256(abi.encode(_proof, _tier, _entityHash));
        if (usedProofs[proofHash]) revert ProofAlreadyUsed();
        usedProofs[proofHash] = true;
        
        latestCommitments[_entityHash] = scoreCommitment;
        lastVerificationTime[_entityHash] = block.timestamp;
        
        emit TierVerified(_entityHash, _tier, scoreCommitment, block.timestamp);
        
        return scoreCommitment;
    }
    
    /**
     * @notice Check if an entity has a valid compliance verification
     * @param _entityHash Hash of entity identifier
     * @param _maxAge Maximum age of verification in seconds
     * @return valid True if entity has verification within maxAge
     */
    function hasValidVerification(
        uint256 _entityHash,
        uint256 _maxAge
    ) external view returns (bool valid) {
        uint256 lastTime = lastVerificationTime[_entityHash];
        return lastTime > 0 && (block.timestamp - lastTime) <= _maxAge;
    }
    
    // =========================================================================
    // Internal Functions
    // =========================================================================
    
    /**
     * @notice Verify Groth16 proof using BN254 pairing
     * @dev Uses precompiled contracts for EC operations
     */
    function _verifyProof(
        Proof memory proof,
        uint256[] memory pubInputs
    ) internal view returns (bool, uint256) {
        // In production, this would implement full Groth16 verification:
        // 1. Check all points are on the curve
        // 2. Check all points are in the correct subgroup
        // 3. Compute vk_x = IC[0] + sum(pubInputs[i] * IC[i+1])
        // 4. Check pairing: e(A, B) = e(alpha, beta) * e(vk_x, gamma) * e(C, delta)
        
        // For now, return placeholder to indicate structure
        // The actual implementation uses bn254 precompiles:
        // - ecAdd (0x06)
        // - ecMul (0x07)  
        // - ecPairing (0x08)
        
        // Placeholder return - actual implementation verifies pairing equation
        // The commitment is the last public signal
        uint256 commitment = 0; // Would be extracted from circuit output
        
        return (true, commitment);
    }
    
    /**
     * @notice Elliptic curve addition on BN254 G1
     */
    function _ecAdd(
        uint256 x1, uint256 y1,
        uint256 x2, uint256 y2
    ) internal view returns (uint256 x, uint256 y) {
        uint256[4] memory input;
        input[0] = x1;
        input[1] = y1;
        input[2] = x2;
        input[3] = y2;
        
        bool success;
        uint256[2] memory result;
        
        assembly {
            success := staticcall(gas(), 6, input, 128, result, 64)
        }
        
        if (!success) revert InvalidPairingInput();
        
        return (result[0], result[1]);
    }
    
    /**
     * @notice Elliptic curve scalar multiplication on BN254 G1
     */
    function _ecMul(
        uint256 x, uint256 y,
        uint256 scalar
    ) internal view returns (uint256 rx, uint256 ry) {
        uint256[3] memory input;
        input[0] = x;
        input[1] = y;
        input[2] = scalar;
        
        bool success;
        uint256[2] memory result;
        
        assembly {
            success := staticcall(gas(), 7, input, 96, result, 64)
        }
        
        if (!success) revert InvalidPairingInput();
        
        return (result[0], result[1]);
    }
    
    /**
     * @notice BN254 pairing check
     * @dev Returns true if sum of pairings equals identity
     */
    function _pairing(uint256[] memory input) internal view returns (bool) {
        uint256 inputSize = input.length;
        
        bool success;
        uint256[1] memory result;
        
        assembly {
            success := staticcall(
                gas(),
                8,
                add(input, 32),
                mul(inputSize, 32),
                result,
                32
            )
        }
        
        if (!success) revert InvalidPairingInput();
        
        return result[0] == 1;
    }
}

/**
 * @title ComplianceRegistry
 * @notice Registry for tracking compliance verifications across entities
 */
contract ComplianceRegistry {
    ComplianceVerifier public verifier;
    
    // Tier names
    string constant TIER_1 = "Critical";
    string constant TIER_2 = "High";
    string constant TIER_3 = "Standard";
    string constant TIER_4 = "Basic";
    string constant TIER_5 = "Minimal";
    
    struct EntityCompliance {
        uint256 commitment;
        uint256 threshold;
        uint8 tier;
        uint256 verifiedAt;
        uint256 expiresAt;
    }
    
    mapping(uint256 => EntityCompliance) public entities;
    
    event EntityRegistered(uint256 indexed entityHash, uint8 tier);
    
    constructor(address _verifier) {
        verifier = ComplianceVerifier(_verifier);
    }
    
    /**
     * @notice Register entity compliance with threshold proof
     */
    function registerWithThreshold(
        uint256[8] calldata _proof,
        uint256 _threshold,
        uint256 _entityHash,
        uint256 _validityPeriod
    ) external {
        uint256 commitment = verifier.verifyThreshold(_proof, _threshold, _entityHash);
        
        uint8 tier = _thresholdToTier(_threshold);
        
        entities[_entityHash] = EntityCompliance({
            commitment: commitment,
            threshold: _threshold,
            tier: tier,
            verifiedAt: block.timestamp,
            expiresAt: block.timestamp + _validityPeriod
        });
        
        emit EntityRegistered(_entityHash, tier);
    }
    
    /**
     * @notice Check if entity is compliant at given tier
     */
    function isCompliantAtTier(uint256 _entityHash, uint8 _requiredTier) external view returns (bool) {
        EntityCompliance memory entity = entities[_entityHash];
        
        if (entity.verifiedAt == 0) return false;
        if (block.timestamp > entity.expiresAt) return false;
        
        return entity.tier <= _requiredTier;
    }
    
    /**
     * @notice Convert threshold to tier
     */
    function _thresholdToTier(uint256 _threshold) internal pure returns (uint8) {
        if (_threshold >= 9500) return 1;
        if (_threshold >= 8500) return 2;
        if (_threshold >= 7000) return 3;
        if (_threshold >= 5000) return 4;
        return 5;
    }
}

